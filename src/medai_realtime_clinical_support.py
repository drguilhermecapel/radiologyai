#!/usr/bin/env python3
"""
MedAI Real-time Clinical Decision Support System
Provides intelligent alerts, recommendations, and collaborative interfaces for radiologists
"""

import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional, Any, Callable
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
import logging
import asyncio
import json
from pathlib import Path

class AlertSeverity(Enum):
    """Alert severity levels for clinical decision support"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"

class AlertType(Enum):
    """Types of clinical alerts"""
    EMERGENCY_FINDING = "emergency_finding"
    CRITICAL_PATHOLOGY = "critical_pathology"
    QUALITY_CONCERN = "quality_concern"
    FOLLOW_UP_NEEDED = "follow_up_needed"
    COMPARISON_AVAILABLE = "comparison_available"
    PROTOCOL_DEVIATION = "protocol_deviation"
    CONTRAST_REACTION = "contrast_reaction"

@dataclass
class ClinicalAlert:
    """Represents a clinical alert generated by the AI system"""
    alert_id: str
    patient_id: str
    study_id: str
    alert_type: AlertType
    severity: AlertSeverity
    title: str
    description: str
    findings: List[str]
    recommendations: List[str]
    confidence_score: float
    timestamp: datetime
    expires_at: Optional[datetime] = None
    acknowledged: bool = False
    acknowledged_by: Optional[str] = None
    acknowledged_at: Optional[datetime] = None
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class ClinicalRecommendation:
    """AI-generated clinical recommendation"""
    recommendation_id: str
    patient_id: str
    category: str
    priority: str
    recommendation_text: str
    evidence: List[str]
    confidence: float
    follow_up_timeframe: Optional[str] = None
    additional_imaging: Optional[List[str]] = None
    clinical_correlation: Optional[str] = None

class RealTimeClinicalAlertSystem:
    """Real-time alert generation and management system"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.alert_rules = self._load_alert_rules()
        self.active_alerts = {}
        self.alert_history = []
        self.notification_handlers = []
        self.logger = logging.getLogger(__name__)
        
    def _load_alert_rules(self) -> Dict[str, Any]:
        """Load clinical alert rules and thresholds"""
        return {
            'emergency_findings': {
                'pneumothorax': {'confidence_threshold': 0.85, 'severity': AlertSeverity.CRITICAL},
                'massive_pe': {'confidence_threshold': 0.80, 'severity': AlertSeverity.CRITICAL},
                'aortic_dissection': {'confidence_threshold': 0.75, 'severity': AlertSeverity.CRITICAL},
                'intracranial_hemorrhage': {'confidence_threshold': 0.80, 'severity': AlertSeverity.CRITICAL}
            },
            'critical_pathology': {
                'large_mass': {'confidence_threshold': 0.70, 'severity': AlertSeverity.HIGH},
                'suspicious_nodule': {'confidence_threshold': 0.65, 'severity': AlertSeverity.MEDIUM},
                'fracture': {'confidence_threshold': 0.75, 'severity': AlertSeverity.HIGH}
            },
            'quality_concerns': {
                'motion_artifact': {'confidence_threshold': 0.60, 'severity': AlertSeverity.MEDIUM},
                'poor_contrast': {'confidence_threshold': 0.70, 'severity': AlertSeverity.LOW},
                'incomplete_study': {'confidence_threshold': 0.80, 'severity': AlertSeverity.MEDIUM}
            }
        }
    
    def evaluate_for_alerts(self, analysis_result: Dict[str, Any]) -> List[ClinicalAlert]:
        """Evaluate analysis results and generate appropriate alerts"""
        alerts = []
        
        predictions = analysis_result.get('predictions', {})
        confidence_scores = analysis_result.get('confidence_scores', {})
        quality_metrics = analysis_result.get('quality_metrics', {})
        
        emergency_alerts = self._check_emergency_findings(predictions, confidence_scores, analysis_result)
        alerts.extend(emergency_alerts)
        
        pathology_alerts = self._check_critical_pathology(predictions, confidence_scores, analysis_result)
        alerts.extend(pathology_alerts)
        
        quality_alerts = self._check_quality_concerns(quality_metrics, analysis_result)
        alerts.extend(quality_alerts)
        
        followup_alerts = self._check_followup_needs(predictions, analysis_result)
        alerts.extend(followup_alerts)
        
        return alerts
    
    def _check_emergency_findings(self, predictions: Dict, confidence_scores: Dict, 
                                analysis_result: Dict) -> List[ClinicalAlert]:
        """Check for emergency findings requiring immediate attention"""
        alerts = []
        
        for finding, rule in self.alert_rules['emergency_findings'].items():
            confidence = confidence_scores.get(finding, 0.0)
            
            if confidence >= rule['confidence_threshold']:
                alert = ClinicalAlert(
                    alert_id=f"EMRG_{finding}_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                    patient_id=analysis_result.get('patient_id', 'UNKNOWN'),
                    study_id=analysis_result.get('study_id', 'UNKNOWN'),
                    alert_type=AlertType.EMERGENCY_FINDING,
                    severity=rule['severity'],
                    title=f"EMERGENCY: {finding.replace('_', ' ').title()} Detected",
                    description=f"AI detected {finding.replace('_', ' ')} with {confidence:.1%} confidence",
                    findings=[f"{finding.replace('_', ' ').title()}: {confidence:.1%} confidence"],
                    recommendations=self._get_emergency_recommendations(finding),
                    confidence_score=confidence,
                    timestamp=datetime.now(),
                    expires_at=datetime.now() + timedelta(hours=24)
                )
                alerts.append(alert)
        
        return alerts
    
    def _check_critical_pathology(self, predictions: Dict, confidence_scores: Dict,
                                analysis_result: Dict) -> List[ClinicalAlert]:
        """Check for critical pathology requiring urgent review"""
        alerts = []
        
        for finding, rule in self.alert_rules['critical_pathology'].items():
            confidence = confidence_scores.get(finding, 0.0)
            
            if confidence >= rule['confidence_threshold']:
                alert = ClinicalAlert(
                    alert_id=f"CRIT_{finding}_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                    patient_id=analysis_result.get('patient_id', 'UNKNOWN'),
                    study_id=analysis_result.get('study_id', 'UNKNOWN'),
                    alert_type=AlertType.CRITICAL_PATHOLOGY,
                    severity=rule['severity'],
                    title=f"Critical Finding: {finding.replace('_', ' ').title()}",
                    description=f"AI detected {finding.replace('_', ' ')} requiring urgent review",
                    findings=[f"{finding.replace('_', ' ').title()}: {confidence:.1%} confidence"],
                    recommendations=self._get_pathology_recommendations(finding),
                    confidence_score=confidence,
                    timestamp=datetime.now(),
                    expires_at=datetime.now() + timedelta(hours=48)
                )
                alerts.append(alert)
        
        return alerts
    
    def _check_quality_concerns(self, quality_metrics: Dict, analysis_result: Dict) -> List[ClinicalAlert]:
        """Check for image quality concerns"""
        alerts = []
        
        for concern, rule in self.alert_rules['quality_concerns'].items():
            quality_score = quality_metrics.get(concern, 0.0)
            
            if quality_score >= rule['confidence_threshold']:
                alert = ClinicalAlert(
                    alert_id=f"QUAL_{concern}_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                    patient_id=analysis_result.get('patient_id', 'UNKNOWN'),
                    study_id=analysis_result.get('study_id', 'UNKNOWN'),
                    alert_type=AlertType.QUALITY_CONCERN,
                    severity=rule['severity'],
                    title=f"Quality Concern: {concern.replace('_', ' ').title()}",
                    description=f"Image quality issue detected: {concern.replace('_', ' ')}",
                    findings=[f"{concern.replace('_', ' ').title()}: {quality_score:.1%} likelihood"],
                    recommendations=self._get_quality_recommendations(concern),
                    confidence_score=quality_score,
                    timestamp=datetime.now()
                )
                alerts.append(alert)
        
        return alerts
    
    def _check_followup_needs(self, predictions: Dict, analysis_result: Dict) -> List[ClinicalAlert]:
        """Check for follow-up imaging needs"""
        alerts = []
        
        nodule_confidence = predictions.get('nodule_detection', 0.0)
        if 0.3 <= nodule_confidence < 0.6:  # Indeterminate findings
            alert = ClinicalAlert(
                alert_id=f"FOLL_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                patient_id=analysis_result.get('patient_id', 'UNKNOWN'),
                study_id=analysis_result.get('study_id', 'UNKNOWN'),
                alert_type=AlertType.FOLLOW_UP_NEEDED,
                severity=AlertSeverity.MEDIUM,
                title="Follow-up Imaging Recommended",
                description="Indeterminate nodule detected requiring follow-up",
                findings=[f"Nodule detection: {nodule_confidence:.1%} confidence"],
                recommendations=["Consider follow-up CT in 3-6 months", "Clinical correlation recommended"],
                confidence_score=nodule_confidence,
                timestamp=datetime.now()
            )
            alerts.append(alert)
        
        return alerts
    
    def _get_emergency_recommendations(self, finding: str) -> List[str]:
        """Get emergency-specific recommendations"""
        recommendations = {
            'pneumothorax': [
                "IMMEDIATE physician notification required",
                "Consider chest tube placement if tension pneumothorax",
                "Monitor patient vitals closely",
                "Prepare for emergency intervention"
            ],
            'massive_pe': [
                "STAT physician notification",
                "Consider thrombolytic therapy",
                "Monitor hemodynamic status",
                "Prepare for possible embolectomy"
            ],
            'aortic_dissection': [
                "IMMEDIATE cardiothoracic surgery consultation",
                "Blood pressure control critical",
                "Avoid anticoagulation",
                "Prepare for emergency surgery"
            ],
            'intracranial_hemorrhage': [
                "STAT neurosurgery consultation",
                "Monitor neurological status",
                "Consider ICP monitoring",
                "Prepare for possible surgical intervention"
            ]
        }
        return recommendations.get(finding, ["Immediate physician review required"])
    
    def _get_pathology_recommendations(self, finding: str) -> List[str]:
        """Get pathology-specific recommendations"""
        recommendations = {
            'large_mass': [
                "Urgent oncology consultation recommended",
                "Consider tissue sampling/biopsy",
                "Staging workup if malignant",
                "Multidisciplinary team review"
            ],
            'suspicious_nodule': [
                "Consider PET-CT for further evaluation",
                "Tissue sampling may be indicated",
                "Follow-up imaging in 3 months",
                "Clinical correlation recommended"
            ],
            'fracture': [
                "Orthopedic consultation recommended",
                "Assess for additional injuries",
                "Consider CT if complex fracture",
                "Pain management and immobilization"
            ]
        }
        return recommendations.get(finding, ["Clinical correlation recommended"])
    
    def _get_quality_recommendations(self, concern: str) -> List[str]:
        """Get quality-specific recommendations"""
        recommendations = {
            'motion_artifact': [
                "Consider repeat imaging if clinically indicated",
                "Patient cooperation and positioning optimization",
                "Sedation may be considered for pediatric patients"
            ],
            'poor_contrast': [
                "Verify contrast administration protocol",
                "Consider delayed phase imaging",
                "Check IV access and injection rate"
            ],
            'incomplete_study': [
                "Complete remaining sequences/phases",
                "Verify protocol compliance",
                "Consider additional views if needed"
            ]
        }
        return recommendations.get(concern, ["Review image quality and consider repeat if needed"])

class AIHumanCollaborationInterface:
    """Interface for AI-human collaboration in radiology workflow"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.active_sessions = {}
        self.feedback_history = []
        self.learning_queue = []
        self.logger = logging.getLogger(__name__)
        
    def create_collaboration_session(self, radiologist_id: str, study_id: str,
                                   ai_analysis: Dict[str, Any]) -> str:
        """Create a new AI-human collaboration session"""
        session_id = f"COLLAB_{study_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        session = {
            'session_id': session_id,
            'radiologist_id': radiologist_id,
            'study_id': study_id,
            'ai_analysis': ai_analysis,
            'start_time': datetime.now(),
            'interactions': [],
            'feedback_provided': False,
            'final_diagnosis': None,
            'agreement_level': None
        }
        
        self.active_sessions[session_id] = session
        return session_id
    
    def record_interaction(self, session_id: str, interaction_type: str,
                          interaction_data: Dict[str, Any]) -> None:
        """Record an interaction between AI and radiologist"""
        if session_id not in self.active_sessions:
            return
        
        interaction = {
            'timestamp': datetime.now(),
            'type': interaction_type,
            'data': interaction_data
        }
        
        self.active_sessions[session_id]['interactions'].append(interaction)
    
    def provide_feedback(self, session_id: str, feedback: Dict[str, Any]) -> None:
        """Radiologist provides feedback on AI analysis"""
        if session_id not in self.active_sessions:
            return
        
        session = self.active_sessions[session_id]
        session['feedback_provided'] = True
        session['final_diagnosis'] = feedback.get('final_diagnosis')
        session['agreement_level'] = feedback.get('agreement_level')
        
        learning_case = {
            'study_id': session['study_id'],
            'ai_prediction': session['ai_analysis'],
            'expert_feedback': feedback,
            'timestamp': datetime.now()
        }
        self.learning_queue.append(learning_case)
        
        self.feedback_history.append({
            'session_id': session_id,
            'feedback': feedback,
            'timestamp': datetime.now()
        })

class ContinuousLearningSystem:
    """System for continuous learning from expert feedback"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.feedback_buffer = []
        self.model_updates = []
        self.performance_metrics = {}
        self.logger = logging.getLogger(__name__)
        
    def process_feedback(self, feedback_data: List[Dict[str, Any]]) -> None:
        """Process expert feedback for model improvement"""
        for feedback in feedback_data:
            self._analyze_feedback(feedback)
            self._update_model_weights(feedback)
            self._track_performance_metrics(feedback)
    
    def _analyze_feedback(self, feedback: Dict[str, Any]) -> None:
        """Analyze feedback to identify improvement opportunities"""
        ai_prediction = feedback.get('ai_prediction', {})
        expert_feedback = feedback.get('expert_feedback', {})
        
        agreement_score = expert_feedback.get('agreement_level', 0.0)
        
        if agreement_score < 0.7:
            self._flag_for_model_review(feedback)
    
    def _update_model_weights(self, feedback: Dict[str, Any]) -> None:
        """Update model weights based on expert feedback"""
        pass
    
    def _track_performance_metrics(self, feedback: Dict[str, Any]) -> None:
        """Track performance metrics over time"""
        timestamp = feedback.get('timestamp', datetime.now())
        agreement = feedback.get('expert_feedback', {}).get('agreement_level', 0.0)
        
        date_key = timestamp.strftime('%Y-%m-%d')
        if date_key not in self.performance_metrics:
            self.performance_metrics[date_key] = []
        
        self.performance_metrics[date_key].append(agreement)
    
    def _flag_for_model_review(self, feedback: Dict[str, Any]) -> None:
        """Flag cases for detailed model review"""
        self.logger.warning(f"Low agreement case flagged: {feedback.get('study_id')}")

class RealTimeClinicalSupportSystem:
    """Main system for real-time clinical decision support"""
    
    def __init__(self, config_path: Optional[str] = None):
        self.config = self._load_config(config_path)
        self.alert_system = RealTimeClinicalAlertSystem(self.config)
        self.collaboration_interface = AIHumanCollaborationInterface(self.config)
        self.learning_system = ContinuousLearningSystem(self.config)
        self.logger = logging.getLogger(__name__)
        
    def _load_config(self, config_path: Optional[str]) -> Dict[str, Any]:
        """Load system configuration"""
        default_config = {
            'alert_enabled': True,
            'collaboration_enabled': True,
            'learning_enabled': True,
            'notification_channels': ['email', 'dashboard', 'mobile'],
            'alert_retention_days': 30
        }
        
        if config_path and Path(config_path).exists():
            pass
            
        return default_config
    
    def process_study_realtime(self, study_data: Dict[str, Any],
                              radiologist_id: Optional[str] = None) -> Dict[str, Any]:
        """Process a study in real-time with clinical decision support"""
        
        alerts = self.alert_system.evaluate_for_alerts(study_data)
        
        collaboration_session = None
        if radiologist_id and self.config.get('collaboration_enabled', True):
            collaboration_session = self.collaboration_interface.create_collaboration_session(
                radiologist_id, study_data.get('study_id', 'UNKNOWN'), study_data
            )
        
        response = {
            'study_id': study_data.get('study_id'),
            'processing_timestamp': datetime.now(),
            'alerts': [self._serialize_alert(alert) for alert in alerts],
            'collaboration_session': collaboration_session,
            'recommendations': self._generate_workflow_recommendations(study_data, alerts),
            'priority_level': self._calculate_priority_level(alerts)
        }
        
        return response
    
    def _serialize_alert(self, alert: ClinicalAlert) -> Dict[str, Any]:
        """Serialize alert for JSON response"""
        return {
            'alert_id': alert.alert_id,
            'type': alert.alert_type.value,
            'severity': alert.severity.value,
            'title': alert.title,
            'description': alert.description,
            'findings': alert.findings,
            'recommendations': alert.recommendations,
            'confidence': alert.confidence_score,
            'timestamp': alert.timestamp.isoformat()
        }
    
    def _generate_workflow_recommendations(self, study_data: Dict[str, Any],
                                         alerts: List[ClinicalAlert]) -> List[str]:
        """Generate workflow recommendations based on analysis and alerts"""
        recommendations = []
        
        if any(alert.severity == AlertSeverity.CRITICAL for alert in alerts):
            recommendations.append("IMMEDIATE physician notification required")
            recommendations.append("Prioritize this case for urgent review")
        
        if any(alert.alert_type == AlertType.QUALITY_CONCERN for alert in alerts):
            recommendations.append("Review image quality before final interpretation")
        
        if not alerts:
            recommendations.append("Routine interpretation workflow")
        
        return recommendations
    
    def _calculate_priority_level(self, alerts: List[ClinicalAlert]) -> str:
        """Calculate overall priority level based on alerts"""
        if any(alert.severity == AlertSeverity.CRITICAL for alert in alerts):
            return "CRITICAL"
        elif any(alert.severity == AlertSeverity.HIGH for alert in alerts):
            return "HIGH"
        elif any(alert.severity == AlertSeverity.MEDIUM for alert in alerts):
            return "MEDIUM"
        else:
            return "ROUTINE"

def main():
    """Example usage of real-time clinical support system"""
    
    system = RealTimeClinicalSupportSystem()
    
    study_data = {
        'study_id': 'ST001',
        'patient_id': 'P001',
        'modality': 'CT',
        'predictions': {
            'pneumothorax': 0.9,
            'nodule_detection': 0.4
        },
        'confidence_scores': {
            'pneumothorax': 0.9,
            'nodule_detection': 0.4
        },
        'quality_metrics': {
            'motion_artifact': 0.2,
            'poor_contrast': 0.1
        }
    }
    
    result = system.process_study_realtime(study_data, radiologist_id="RAD001")
    
    print("Real-time Clinical Support Results:")
    print(f"Study ID: {result['study_id']}")
    print(f"Priority Level: {result['priority_level']}")
    print(f"Number of Alerts: {len(result['alerts'])}")
    
    for alert in result['alerts']:
        print(f"- {alert['severity'].upper()}: {alert['title']}")

if __name__ == "__main__":
    main()
